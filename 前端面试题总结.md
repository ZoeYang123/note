# 总结

##### js数据类型

> 原始数据类型 ( 直接存储在栈（stack）中 )

- undefined
- null
- Boolean
- Number
- String
- Symbol(es6新增)
- BigInt(es10新增)

> 引用数据类型 ( 同时存储在栈（stack）和堆（heap）中 )

- function
- Array
- Date
- Object

##### js数据类型转换

- 转换为布尔值 - Boolean()
- 转换为数值 - Number()、parseInt()、parseFloat()
- 转换为字符串 - toString()、String()

##### js数据类型的判断

> typeof

typeof对于原始类型来说，除了null都可以显示正确的类型

```javascript
typeof 2;                  //number
typeof true;               //boolean
typeof 'Yang';             //string
typeof [];                 //object
typeof function(){};       //function
typeof {};                 //object
typeof undefined;          //undefined
typeof null;               //object
typeof new Date();         //object
```

typeof对于对象来说，除了函数都会显示object，所以说typeof并不能准确判断变量到底是什么类型

> instanceof

instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上（某个对象的实例）

```javascript
2 instanceof Number;                   //false
true instanceof Boolean;               //false
'str' instanceof String;               //false
[] instanceof Array;                   //true
function(){} Function;                 //true;
{} instanceof Object;                  //true
```

instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。

instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性，判断一个对象是否是数据类型的实例

> constructor

```javascript
(2).constructor === Number;               //true
(true).constructor === Boolean;           //true
('str').constructor === String;           //true
([]).constructor === Array;               //true
(function(){}).constructor === Function;  //true
({}).constructor === Object;              //true

这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了
function Fn(){};

Fn.prototype=new Array();

var f=new Fn();

console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true
```

> Object.prototype.toString.call()