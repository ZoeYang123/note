# 总结

##### 1.js数据类型

> 原始数据类型 ( 直接存储在栈（stack）中 )

- undefined
- null
- Boolean
- Number
- String
- Symbol(es6新增)
- BigInt(es10新增)

> 引用数据类型 ( 同时存储在栈（stack）和堆（heap）中 )

- function
- Array
- Date
- Object

##### 2.js数据类型转换

- 转换为布尔值 - Boolean()
- 转换为数值 - Number()、parseInt()、parseFloat()
- 转换为字符串 - toString()、String()

##### 3.js数据类型的判断

> typeof

typeof对于原始类型来说，除了null都可以显示正确的类型

```javascript
typeof 2;                  //number
typeof true;               //boolean
typeof 'Yang';             //string
typeof [];                 //object
typeof function(){};       //function
typeof {};                 //object
typeof undefined;          //undefined
typeof null;               //object
typeof new Date();         //object
```

typeof对于对象来说，除了函数都会显示object，所以说typeof并不能准确判断变量到底是什么类型

> instanceof

instanceof运算符用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上（某个对象的实例）

```javascript
2 instanceof Number;                   //false
true instanceof Boolean;               //false
'str' instanceof String;               //false
[] instanceof Array;                   //true
function(){} Function;                 //true;
{} instanceof Object;                  //true
```

instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。

instanceof运算符用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性，判断一个对象是否是数据类型的实例

> constructor

```javascript
(2).constructor === Number;               //true
(true).constructor === Boolean;           //true
('str').constructor === String;           //true
([]).constructor === Array;               //true
(function(){}).constructor === Function;  //true
({}).constructor === Object;              //true

这里有一个坑，如果我创建一个对象，更改它的原型，constructor就会变得不可靠了
function Fn(){};

Fn.prototype=new Array();

var f=new Fn();

console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true
```

> Object.prototype.toString.call()



##### 4.js内置对象





##### 5.null和undefined的区别

这两个都是基本数据类型，使用 typeof 进行判断的时候，null 类型化会返回

- undefined代表含义未定义。 一般变量声明了但没有定义，会返回undefined
- null代表的含义是空对象。主要用于赋值给一些可能会返回对象的变量，作为初始化

##### 6.{}和[]的valueOf()和toString()的结果是什么？

```javascript
{}.valueOf();     //{}
[].valueOf();     //[]
{}.toString();    //"[object Object]"
[].toString();    //""
```

##### 7.作用域和作用域链

##### 8.创建对象的几种方式

##### 9.继承的几种实现方式

##### 10.寄生式组合继承的实现

##### 11.this、call、apply、bind的理解

> this永远指向最后调用它的那个对象。

- 在浏览器里，在全局范围内this指向window对象；
- 在函数中，this永远指向最后调用它的那个对象；
- 构造函数中，this指向new出来的那个新对象;
- call、apply、bind中的this被强绑定在指定的那个对象上；
- 箭头函数中的this比较特殊，箭头函数的this为父作用域的this，不是调用时的this。箭头函数的this指向是静态的，声明的时候就确定了

> apply()方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。
>
> ```javascript
> func.apply(thisArg, [argsArray])
> ```

apply函数实现步骤

```javascript
// apply 函数实现
Function.prototype.myApply = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  let result = null;

  // 判断 context 是否存在，如果未传入则为 window
  context = context || window;

  // 将函数设为对象的方法
  context.fn = this;

  // 调用方法
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }

  // 将属性删除
  delete context.fn;

  return result;
};
```

> call()方法使用一个指定的this值和单独给出的一个或多个参数来调用一个函数